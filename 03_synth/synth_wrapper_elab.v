
// Generated by Cadence Genus(TM) Synthesis Solution GENUS15.20 - 15.20-p004_1
// Generated on: May 17 2025 05:37:49

// Verification Directory fv/synth_wrapper 

module cla_4bit(a, b, cin, s);
  input [3:0] a, b;
  input cin;
  output [3:0] s;
  wire [3:0] a, b;
  wire cin;
  wire [3:0] s;
  wire [3:0] p;
  wire [3:0] g;
  wire \c[1] , \c[2] , \c[3] , n_9, n_10, n_11, n_12, n_13;
  wire n_14, n_15, n_17, n_19, n_21;
  and g3 (n_9, p[0], cin);
  or g4 (\c[1] , g[0], n_9);
  and g5 (n_10, p[1], g[0]);
  or g6 (n_12, g[1], n_10);
  and g7 (n_11, p[1], p[0]);
  and g8 (n_13, n_11, cin);
  or g9 (\c[2] , n_12, n_13);
  and g10 (n_14, p[2], g[1]);
  and g12 (n_15, p[2], p[1]);
  and g13 (n_17, n_15, g[0]);
  and g16 (n_19, n_15, p[0]);
  and g17 (n_21, n_19, cin);
  xor g1 (p[0], a[0], b[0]);
  xor g20 (p[1], a[1], b[1]);
  xor g21 (p[2], a[2], b[2]);
  xor g22 (p[3], a[3], b[3]);
  and g23 (g[0], a[0], b[0]);
  and g2 (g[1], a[1], b[1]);
  and g24 (g[2], a[2], b[2]);
  xor g26 (s[0], p[0], cin);
  xor g27 (s[1], p[1], \c[1] );
  xor g28 (s[2], p[2], \c[2] );
  xor g29 (s[3], p[3], \c[3] );
  or g30 (\c[3] , g[2], n_14, n_17, n_21);
endmodule

module bmux(ctl, in_0, in_1, z);
  input ctl;
  input [3:0] in_0, in_1;
  output [3:0] z;
  wire ctl;
  wire [3:0] in_0, in_1;
  wire [3:0] z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0[3]), .data1 (in_1[3]), .z
       (z[3]));
  CDN_bmux2 g2(.sel0 (ctl), .data0 (in_0[2]), .data1 (in_1[2]), .z
       (z[2]));
  CDN_bmux2 g3(.sel0 (ctl), .data0 (in_0[1]), .data1 (in_1[1]), .z
       (z[1]));
  CDN_bmux2 g4(.sel0 (ctl), .data0 (in_0[0]), .data1 (in_1[0]), .z
       (z[0]));
endmodule

module counter_4bit(clk, rst_n, sel, out);
  input clk, rst_n, sel;
  output [3:0] out;
  wire clk, rst_n, sel;
  wire [3:0] out;
  wire [3:0] count_value;
  wire [3:0] n_count;
  wire UNCONNECTED, UNCONNECTED0, UNCONNECTED1, UNCONNECTED2, n_5;
  cla_4bit sum(.a (out), .b ({count_value[1], count_value[1],
       count_value[1], sel}), .cin (count_value[1]), .s (n_count));
  bmux mux_p_count_19_12(.ctl (n_5), .in_0 (n_count), .in_1 (4'b0000),
       .z ({UNCONNECTED2, UNCONNECTED1, UNCONNECTED0, UNCONNECTED}));
  not g1 (count_value[1], sel);
  not g2 (n_5, rst_n);
  CDN_flop \p_count_reg[0] (.clk (clk), .d (n_count[0]), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[0]));
  CDN_flop \p_count_reg[1] (.clk (clk), .d (n_count[1]), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[1]));
  CDN_flop \p_count_reg[2] (.clk (clk), .d (n_count[2]), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[2]));
  CDN_flop \p_count_reg[3] (.clk (clk), .d (n_count[3]), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[3]));
endmodule

module bmux_1(ctl, in_0, in_1, z);
  input ctl, in_0, in_1;
  output z;
  wire ctl, in_0, in_1;
  wire z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0), .data1 (in_1), .z (z));
endmodule

module synth_wrapper(clk, rst_n, sel, count);
  input clk, rst_n, sel;
  output [3:0] count;
  wire clk, rst_n, sel;
  wire [3:0] count;
  wire UNCONNECTED3, UNCONNECTED4, UNCONNECTED5, UNCONNECTED6,
       UNCONNECTED7, \count_reg[0]_16 , \count_reg[1]_17 ,
       \count_reg[2]_18 ;
  wire \count_reg[3]_19 , n_6, sel_reg;
  counter_4bit counter(.clk (clk), .rst_n (rst_n), .sel (sel_reg), .out
       ({\count_reg[3]_19 , \count_reg[2]_18 , \count_reg[1]_17 ,
       \count_reg[0]_16 }));
  bmux_1 mux_sel_reg_14_12(.ctl (n_6), .in_0 (sel), .in_1 (1'b0), .z
       (UNCONNECTED3));
  bmux mux_count_24_12(.ctl (n_6), .in_0 ({\count_reg[3]_19 ,
       \count_reg[2]_18 , \count_reg[1]_17 , \count_reg[0]_16 }), .in_1
       (4'b0000), .z ({UNCONNECTED7, UNCONNECTED6, UNCONNECTED5,
       UNCONNECTED4}));
  not g1 (n_6, rst_n);
  CDN_flop sel_reg_reg(.clk (clk), .d (sel), .sena (1'b1), .aclr (n_6),
       .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (sel_reg));
  CDN_flop \count_reg[0] (.clk (clk), .d (\count_reg[0]_16 ), .sena
       (1'b1), .aclr (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (count[0]));
  CDN_flop \count_reg[1] (.clk (clk), .d (\count_reg[1]_17 ), .sena
       (1'b1), .aclr (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (count[1]));
  CDN_flop \count_reg[2] (.clk (clk), .d (\count_reg[2]_18 ), .sena
       (1'b1), .aclr (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (count[2]));
  CDN_flop \count_reg[3] (.clk (clk), .d (\count_reg[3]_19 ), .sena
       (1'b1), .aclr (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (count[3]));
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  wire z;
  wire inv_sel0, w_0, w_1;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
